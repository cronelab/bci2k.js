{"version":3,"sources":["webpack://BCI2K/webpack/universalModuleDefinition","webpack://BCI2K/./bci2k.ts","webpack://BCI2K/external \"websocket\"","webpack://BCI2K/webpack/bootstrap","webpack://BCI2K/webpack/startup"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__913__","websocket","BCI2K_DataConnection","address","_socket","onconnect","onGenericSignal","data","onStateVector","onSignalProperties","onStateFormat","ondisconnect","onReceiveBlock","callingFrom","states","signal","signalProperties","stateFormat","stateVecOrder","SignalType","INT16","FLOAT24","FLOAT32","INT32","dv","val","count","byteLength","v","getUint8","String","fromCharCode","reconnect","connection","undefined","Promise","resolve","reject","binaryType","onerror","onopen","onclose","e","setTimeout","console","log","connect","onmessage","event","_decodeMessage","readyState","OPEN","descriptor","DataView","stateFormatView","_decodeStateFormat","supplement","genericSignalView","_decodeGenericSignal","signalPropertyView","_decodeSignalProperties","error","toString","stateVectorView","_decodeStateVector","unitstr","units","unit","split","idx","offset","Number","gain","symbol","vmin","vmax","propstr","getNullTermString","replace","prop_tokens","props","i","length","trim","push","pidx","name","channels","numChannels","parseInt","elements","numElements","numelements","signaltype","channelunit","_decodePhysicalUnits","slice","join","elementunit","valueunits","lines","lineIdx","stateline","bitWidth","defaultValue","byteLocation","bitLocation","vecOrder","state","loc","sort","a","b","index","signalType","nChannels","getUint16","nElements","byteOffset","signalData","buffer","ch","el","getInt16","getFloat32","getInt32","i8Array","Int8Array","firstZero","indexOf","secondZero","decoder","TextDecoder","stateVectorLength","decode","numVectors","Array","fill","vecIdx","vec","Uint8Array","bits","byteIdx","stateIdx","fmt","mask","bIdx","bciOperator","onStateChange","_execid","_exec","opcode","id","contents","JSON","parse","location","locationParameter","execute","then","dataConnection","instruction","connected","exec","send","stringify","x","ip","port","setInterval","allData","forEach","line","descriptors","dataType","names","value","low","high","comment","bciData","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"websocket\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"websocket\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"BCI2K\"] = factory(require(\"websocket\"));\n\telse\n\t\troot[\"BCI2K\"] = factory(root[\"websocket\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__913__) {\nreturn ","// ======================================================================== //\n//\n// bci2k.js\n// A javascript connector for BCI2000\n//\n// ======================================================================== //\n\n//To see how the BCI2000 messages are implemented in BCI2000 see here:\n// https://www.bci2000.org/mediawiki/index.php/Technical_Reference:BCI2000_Messages\n\nconst websocket = require(\"websocket\").w3cwebsocket;\n\nclass BCI2K_OperatorConnection {\n  websocket: WebSocket;\n  _execid: any;\n  _exec: any;\n  state: any;\n  ondisconnect: any;\n  onStateChange: any;\n  address: string;\n\n  constructor(address?: string) {\n    this.ondisconnect = () => { };\n    this.onStateChange = (event: string) => { };\n\n    // this.websocket = null;\n    this._execid = 0;\n    this._exec = {};\n    this.state = \"\";\n    this.address = address;\n  }\n\n  public connect(address?: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (this.address === undefined) {\n        this.address =\n          address || \"ws://127.0.0.1:80\" || `ws://{window.location.host}`;\n      }\n\n      this.websocket = new websocket(this.address);\n\n      this.websocket.onerror = (error) => {\n        // This will only execute if we err before connecting, since\n        // Promises can only get triggered once\n        reject(\"Error connecting to BCI2000 at \" + this.address);\n      };\n\n      this.websocket.onopen = () => {\n        resolve();\n      };\n\n      this.websocket.onclose = () => {\n        this.ondisconnect();\n      };\n\n      this.websocket.onmessage = (event) => {\n        let { opcode, id, contents } = JSON.parse(event.data);\n        switch (opcode) {\n          case \"O\": // OUTPUT: Received output from command\n            this._exec[id](contents);\n            delete this._exec[id];\n            break;\n          default:\n            break;\n        }\n      };\n    });\n  }\n\n  public tap(location: string) {\n    let connection = this;\n\n    let locationParameter = \"WS\" + location + \"Server\";\n\n    return this.execute(\"Get Parameter \" + locationParameter).then(\n      (location: string) => {\n        if (location.indexOf(\"does not exist\") >= 0) {\n          return Promise.reject(\"Location parameter does not exist\");\n        }\n        if (location === \"\") {\n          return Promise.reject(\"Location parameter not set\");\n        }\n\n        let dataConnection = new BCI2K_DataConnection();\n\n        // Use our address plus the port from the result\n        return dataConnection\n          .connect(connection.address + \":\" + location.split(\":\")[1], \"\")\n          .then((event) => {\n            // To keep with our old API, we actually want to wrap the\n            // dataConnection, and not the connection event\n            // TODO This means we can't get the connection event!\n            return dataConnection;\n          });\n      }\n    );\n  }\n\n  public connected() {\n    return (\n      this.websocket !== null && this.websocket.readyState === websocket.OPEN\n    );\n  }\n\n  public execute(instruction: string) {\n    let connection = this;\n    if (this.connected()) {\n      return new Promise((resolve, reject) => {\n        let id = (++connection._execid).toString();\n        // TODO Properly handle errors from BCI2000\n        connection._exec[id] = (exec) => resolve(exec);\n        connection.websocket.send(\n          JSON.stringify({\n            opcode: \"E\",\n            id: id,\n            contents: instruction,\n          })\n        );\n      });\n    }\n    // Cannot execute if not connected\n    return Promise.reject(\n      \"Cannot execute instruction: not connected to BCI2000\"\n    );\n  }\n\n  getVersion() {\n    this.execute(\"Version\").then((x: string) => console.log(x.split(\" \")[1]));\n  }\n\n  showWindow() {\n    return this.execute(\"Show Window\");\n  }\n\n  hideWindow() {\n    return this.execute(\"Hide Window\");\n  }\n\n  setWatch(state: string, ip: string, port: string) {\n    return this.execute(\"Add watch \" + state + \" at \" + ip + \":\" + port);\n  }\n\n  resetSystem() {\n    return this.execute(\"Reset System\");\n  }\n\n  setConfig() {\n    return this.execute(\"Set Config\");\n  }\n\n  start() {\n    return this.execute(\"Start\");\n  }\n\n  stop() {\n    return this.execute(\"Stop\");\n  }\n\n  kill() {\n    return this.execute(\"Exit\");\n  }\n\n  stateListen() {\n    setInterval(() => {\n      this.execute(\"GET SYSTEM STATE\").then((state: string) => {\n        if (state.trim() != this.state) {\n          this.onStateChange(state.trim());\n          this.state = state.trim();\n        }\n      });\n    }, 500);\n  }\n\n  async getSubjectName() {\n    //Promise<string> {\n    return await this.execute(\"Get Parameter SubjectName\");\n  }\n\n  async getTaskName() {\n    return await this.execute(\"Get Parameter DataFile\");\n  }\n  //See https://www.bci2000.org/mediawiki/index.php/Technical_Reference:Parameter_Definition\n  async getParameters() {\n    let parameters: any = await this.execute(\"List Parameters\");\n    let allData = parameters.split(\"\\n\");\n    let data = {};\n    let el;\n    allData.forEach(line => {\n      let descriptors = line.split(\"=\")[0]\n      let dataType = descriptors.split(\" \")[1]\n      let name = descriptors.split(\" \")[2]\n      let names = descriptors.split(\" \")[0].split(\":\");\n      names.forEach((x, i) => {\n        switch (i) {\n          case 0: {\n            if (data[names[0]] == undefined) {\n              data[names[0]] = {}\n            }\n            el = data[names[0]]\n            break;\n          }\n          case 1: {\n            if (data[names[0]][names[1]] == undefined) {\n              data[names[0]][names[1]] = {}\n            }\n            el = data[names[0]][names[1]]\n            break;\n          }\n          case 2: {\n            if (data[names[0]][names[1]][names[2]] == undefined) {\n              data[names[0]][names[1]][names[2]] = {}\n            }\n            el = data[names[0]][names[1]][names[2]]\n            break;\n          }\n          default: { }\n        }\n      })\n\n      if (dataType != \"matrix\") {\n        if (line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \").length == 4) {\n          el[name] = {\n            dataType,\n            value: {\n              value: line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \")[0],\n              defaultValue: line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \")[1],\n              low: line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \")[2],\n              high: line.split(\"=\")[1].split(\"//\")[0].trim().split(\" \")[3],\n            },\n            comment: line.split(\"=\")[1].split(\"//\")[1]\n          }\n        }\n        else {\n          el[name] = {\n            dataType,\n            value: line.split(\"=\")[1].split(\"//\")[0].trim(),\n            comment: line.split(\"=\")[1].split(\"//\")[1]\n          }\n        }\n      }\n      else {\n        el[name] = {\n          dataType,\n          value: line.split(\"=\")[1].split(\"//\")[0].trim(),\n          comment: line.split(\"=\")[1].split(\"//\")[1]\n        }\n      }\n\n    });\n\n    return data\n  }\n}\n\nclass BCI2K_DataConnection {\n  _socket: WebSocket;\n  states: any;\n  signal: any;\n  signalProperties: any;\n  stateFormat: any;\n  stateVecOrder: any;\n  SignalType: any;\n  callingFrom: any;\n  onconnect: any;\n  onGenericSignal: any;\n  onStateVector: any;\n  onSignalProperties: any;\n  onStateFormat: any;\n  ondisconnect: any;\n  onReceiveBlock: any;\n  address: string;\n  constructor(address?: string) {\n    this._socket = null;\n\n    this.onconnect = () => { };\n    this.onGenericSignal = (data: any) => { };\n    this.onStateVector = (data: any) => { };\n    this.onSignalProperties = (data: any) => { };\n    this.onStateFormat = (data: any) => { };\n    this.ondisconnect = () => { };\n    this.onReceiveBlock = () => { };\n\n    this.callingFrom = \"\";\n\n    this.states = {};\n    this.signal = null;\n    this.signalProperties = null;\n    this.stateFormat = null;\n    this.stateVecOrder = null;\n\n    this.SignalType = {\n      INT16: 0,\n      FLOAT24: 1,\n      FLOAT32: 2,\n      INT32: 3,\n    };\n    this.address = address;\n  }\n\n  private getNullTermString(dv: DataView) {\n    var val = \"\";\n    let count = 0;\n    while (count < dv.byteLength) {\n      var v = dv.getUint8(count);\n      count++;\n      if (v == 0) break;\n      val += String.fromCharCode(v);\n    }\n    return val;\n  }\n\n  connect(address?: string, callingFrom?: string, reconnect?: boolean) {\n    let connection = this;\n    if (connection.address === undefined) connection.address = address;\n    this.callingFrom = callingFrom;\n    return new Promise<void>((resolve, reject) => {\n      connection._socket = new websocket(connection.address);\n      connection._socket.binaryType = \"arraybuffer\";\n\n      connection._socket.onerror = () => {\n        // This will only execute if we err before connecting, since\n        // Promises can only get triggered once\n        reject(\"Error connecting to data source at \" + connection.address);\n      };\n\n      connection._socket.onopen = () => {\n        connection.onconnect();\n        resolve();\n      };\n\n      connection._socket.onclose = (e) => {\n        connection.ondisconnect();\n        setTimeout(() => {\n          console.log(\"Disconnected\");\n          if (reconnect != false) {\n            this.connect(\"\");\n          }\n        }, 1000);\n      };\n\n      connection._socket.onmessage = (event) => {\n        connection._decodeMessage(event.data);\n      };\n    });\n  }\n\n  connected(): boolean {\n    return this._socket != null && this._socket.readyState === websocket.OPEN;\n  }\n\n  private _decodeMessage(data: ArrayBuffer) {\n    let descriptor = new DataView(data, 0, 1).getUint8(0);\n    switch (descriptor) {\n      case 3:\n        let stateFormatView = new DataView(data, 1, data.byteLength - 1);\n        this._decodeStateFormat(stateFormatView);\n        break;\n\n      case 4:\n        let supplement = new DataView(data, 1, 2).getUint8(0);\n        switch (supplement) {\n          case 1:\n            let genericSignalView = new DataView(data, 2, data.byteLength - 2);\n            this._decodeGenericSignal(genericSignalView);\n            break;\n          case 3:\n            let signalPropertyView = new DataView(data, 2, data.byteLength - 2);\n            this._decodeSignalProperties(signalPropertyView);\n            break;\n          default:\n            console.error(\"Unsupported Supplement: \" + supplement.toString());\n            break;\n        }\n        this.onReceiveBlock();\n\n        break;\n\n      case 5:\n        let stateVectorView = new DataView(data, 1, data.byteLength - 1);\n        this._decodeStateVector(stateVectorView);\n        break;\n\n      default:\n        console.error(\"Unsupported Descriptor: \" + descriptor.toString());\n        break;\n    }\n  }\n\n  private _decodePhysicalUnits(unitstr: string) {\n    let units: any;\n    units = {};\n    let unit = unitstr.split(\" \");\n    let idx = 0;\n    units.offset = Number(unit[idx++]);\n    units.gain = Number(unit[idx++]);\n    units.symbol = unit[idx++];\n    units.vmin = Number(unit[idx++]);\n    units.vmax = Number(unit[idx++]);\n    return units;\n  }\n\n  private _decodeSignalProperties(data: DataView) {\n    let propstr = this.getNullTermString(data);\n    // Bugfix: There seems to not always be spaces after '{' characters\n    propstr = propstr.replace(/{/g, \" { \");\n    propstr = propstr.replace(/}/g, \" } \");\n\n    this.signalProperties = {};\n    let prop_tokens = propstr.split(\" \");\n    let props = [];\n    for (let i = 0; i < prop_tokens.length; i++) {\n      if (prop_tokens[i].trim() === \"\") continue;\n      props.push(prop_tokens[i]);\n    }\n\n    let pidx = 0;\n    this.signalProperties.name = props[pidx++];\n\n    this.signalProperties.channels = [];\n    if (props[pidx] === \"{\") {\n      while (props[++pidx] !== \"}\")\n        this.signalProperties.channels.push(props[pidx]);\n      pidx++; // }\n    } else {\n      let numChannels = parseInt(props[pidx++]);\n      for (let i = 0; i < numChannels; i++)\n        this.signalProperties.channels.push((i + 1).toString());\n    }\n\n    this.signalProperties.elements = [];\n    if (props[pidx] === \"{\") {\n      while (props[++pidx] !== \"}\")\n        this.signalProperties.elements.push(props[pidx]);\n      pidx++; // }\n    } else {\n      let numElements = parseInt(props[pidx++]);\n      for (let i = 0; i < numElements; i++)\n        this.signalProperties.elements.push((i + 1).toString());\n    }\n\n    // Backward Compatibility\n    this.signalProperties.numelements = this.signalProperties.elements.length;\n    this.signalProperties.signaltype = props[pidx++];\n    this.signalProperties.channelunit = this._decodePhysicalUnits(\n      props.slice(pidx, (pidx += 5)).join(\" \")\n    );\n\n    this.signalProperties.elementunit = this._decodePhysicalUnits(\n      props.slice(pidx, (pidx += 5)).join(\" \")\n    );\n\n    pidx++; // '{'\n\n    this.signalProperties.valueunits = [];\n    for (let i = 0; i < this.signalProperties.channels.length; i++)\n      this.signalProperties.valueunits.push(\n        this._decodePhysicalUnits(props.slice(pidx, (pidx += 5)).join(\" \"))\n      );\n\n    pidx++; // '}'\n    this.onSignalProperties(this.signalProperties);\n  }\n\n  private _decodeStateFormat(data: DataView) {\n    this.stateFormat = {};\n    let formatStr = this.getNullTermString(data);\n\n    let lines = formatStr.split(\"\\n\");\n    for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {\n      if (lines[lineIdx].trim().length === 0) continue;\n      let stateline = lines[lineIdx].split(\" \");\n      let name = stateline[0];\n      this.stateFormat[name] = {};\n      this.stateFormat[name].bitWidth = parseInt(stateline[1]);\n      this.stateFormat[name].defaultValue = parseInt(stateline[2]);\n      this.stateFormat[name].byteLocation = parseInt(stateline[3]);\n      this.stateFormat[name].bitLocation = parseInt(stateline[4]);\n    }\n\n    let vecOrder = [];\n    for (let state in this.stateFormat) {\n      let loc = this.stateFormat[state].byteLocation * 8;\n      loc += this.stateFormat[state].bitLocation;\n      vecOrder.push([state, loc]);\n    }\n\n    // Sort by bit location\n    vecOrder.sort((a, b) => (a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0));\n\n    // Create a list of ( state, bitwidth ) for decoding state vectors\n    this.stateVecOrder = [];\n    for (let i = 0; i < vecOrder.length; i++) {\n      let state = vecOrder[i][0];\n      this.stateVecOrder.push([state, this.stateFormat[state].bitWidth]);\n    }\n\n    this.onStateFormat(this.stateFormat);\n  }\n\n  private _decodeGenericSignal(data: DataView) {\n    let index = 0;\n    let signalType = data.getUint8(index);\n    index = index + 1;\n    let nChannels = data.getUint16(index, true);\n    index = index + 2;\n    let nElements = data.getUint16(index, true);\n    index = index + 2;\n    index = index + data.byteOffset;\n    let signalData = new DataView(data.buffer, index);\n    let signal = [];\n    for (let ch = 0; ch < nChannels; ++ch) {\n      signal.push([]);\n      for (let el = 0; el < nElements; ++el) {\n        switch (signalType) {\n          case this.SignalType.INT16:\n            signal[ch].push(\n              signalData.getInt16((nElements * ch + el) * 2, true)\n            );\n            break;\n\n          case this.SignalType.FLOAT32:\n            signal[ch].push(\n              signalData.getFloat32((nElements * ch + el) * 4, true)\n            );\n            break;\n\n          case this.SignalType.INT32:\n            signal[ch].push(\n              signalData.getInt32((nElements * ch + el) * 4, true)\n            );\n            break;\n\n          case this.SignalType.FLOAT24:\n            // TODO: Currently Unsupported\n            signal[ch].push(0.0);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    this.signal = signal;\n    this.onGenericSignal(signal);\n  }\n\n  private _decodeStateVector(dv: DataView) {\n    if (this.stateVecOrder == null) return;\n    // Currently, states are maximum 32 bit unsigned integers\n    // BitLocation 0 refers to the least significant bit of a byte in the packet\n    // ByteLocation 0 refers to the first byte in the sequence.\n    // Bits must be populated in increasing significance\n\n    let i8Array = new Int8Array(dv.buffer);\n    let firstZero = i8Array.indexOf(0);\n    let secondZero = i8Array.indexOf(0, firstZero + 1);\n\n    let decoder = new TextDecoder();\n    let stateVectorLength = parseInt(decoder.decode(i8Array.slice(1, firstZero)))\n    let numVectors = parseInt(decoder.decode(i8Array.slice(firstZero + 1, secondZero)))\n\n    let index = secondZero + 1;\n\n    let data = new DataView(dv.buffer, index);\n    let states = {};\n    for (let state in this.stateFormat) {\n      states[state] = Array(numVectors).fill(\n        this.stateFormat[state].defaultValue\n      );\n    }\n    for (let vecIdx = 0; vecIdx < numVectors; vecIdx++) {\n      let vec = new Uint8Array(\n        data.buffer,\n        data.byteOffset + vecIdx * stateVectorLength,\n        stateVectorLength\n      );\n      let bits = [];\n      for (let byteIdx = 0; byteIdx < vec.length; byteIdx++) {\n        bits.push((vec[byteIdx] & 0x01) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x02) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x04) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x08) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x10) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x20) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x40) !== 0 ? 1 : 0);\n        bits.push((vec[byteIdx] & 0x80) !== 0 ? 1 : 0);\n      }\n\n      for (let stateIdx = 0; stateIdx < this.stateVecOrder.length; stateIdx++) {\n        let fmt = this.stateFormat[this.stateVecOrder[stateIdx][0]];\n        let offset = fmt.byteLocation * 8 + fmt.bitLocation;\n        let val = 0;\n        let mask = 0x01;\n        for (let bIdx = 0; bIdx < fmt.bitWidth; bIdx++) {\n          if (bits[offset + bIdx]) val = (val | mask) >>> 0;\n          mask = (mask << 1) >>> 0;\n        }\n        states[this.stateVecOrder[stateIdx][0]][vecIdx] = val;\n      }\n    }\n    this.onStateVector(states);\n    this.states = states;\n  }\n}\n\nmodule.exports = {\n  bciOperator: BCI2K_OperatorConnection,\n  bciData: BCI2K_DataConnection,\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__913__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(463);\n"],"sourceRoot":""}